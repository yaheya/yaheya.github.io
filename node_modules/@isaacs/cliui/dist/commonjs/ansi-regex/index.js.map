{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/ansi-regex/index.ts"],"names":[],"mappings":";AAAA,wDAAwD;;;AAEjD,MAAM,SAAS,GAAG,CAAC,EAAE,SAAS,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE,EAAE;IACtD,4DAA4D;IAC5D,MAAM,EAAE,GAAG,oCAAoC,CAAC;IAEhD,mEAAmE;IACnE,MAAM,GAAG,GAAG,0BAA0B,EAAE,GAAG,CAAC;IAE5C,sGAAsG;IACtG,MAAM,GAAG,GACP,oFAAoF,CAAC;IAEvF,MAAM,OAAO,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,CAAC;IAEhC,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;AAC1D,CAAC,CAAC;AAdW,QAAA,SAAS,aAcpB","sourcesContent":["// TODO! cut this down? do we need the onlyFirst option?\n\nexport const ansiRegex = ({ onlyFirst = false } = {}) => {\n  // Valid string terminator sequences are BEL, ESC\\, and 0x9c\n  const ST = \"(?:\\\\u0007|\\\\u001B\\\\u005C|\\\\u009C)\";\n\n  // OSC sequences only: ESC ] ... ST (non-greedy until the first ST)\n  const osc = `(?:\\\\u001B\\\\][\\\\s\\\\S]*?${ST})`;\n\n  // CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte\n  const csi =\n    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:\\\\d{1,4}(?:[;:]\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]\";\n\n  const pattern = `${osc}|${csi}`;\n\n  return new RegExp(pattern, onlyFirst ? undefined : \"g\");\n};\n"]}