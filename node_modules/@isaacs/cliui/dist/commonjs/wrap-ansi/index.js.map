{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/wrap-ansi/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { stringWidth } from \"../string-width/index.js\";\nimport { stripAnsi } from \"../strip-ansi/index.js\";\nimport { ansiStyles } from \"../ansi-styles/index.js\";\n\nconst ESCAPES = new Set([\"\\u001B\", \"\\u009B\"]);\n\nconst END_CODE = 39;\nconst ANSI_ESCAPE_BELL = \"\\u0007\";\nconst ANSI_CSI = \"[\";\nconst ANSI_OSC = \"]\";\nconst ANSI_SGR_TERMINATOR = \"m\";\nconst ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;\n\nconst wrapAnsiCode = (code: number) =>\n  `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;\nconst wrapAnsiHyperlink = (uri: string) =>\n  `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = (str: string) =>\n  str.split(\" \").map((character) => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows: string[], word: string, columns: number) => {\n  const characters = [...word];\n\n  let isInsideEscape = false;\n  let isInsideLinkEscape = false;\n  let visible = stringWidth(stripAnsi(String(rows[rows.length - 1])));\n\n  for (const [index, character] of characters.entries()) {\n    const characterLength = stringWidth(character);\n\n    if (visible + characterLength <= columns) {\n      rows[rows.length - 1] += character;\n    } else {\n      rows.push(character);\n      visible = 0;\n    }\n\n    if (ESCAPES.has(character)) {\n      isInsideEscape = true;\n      isInsideLinkEscape = characters\n        .slice(index + 1)\n        .join(\"\")\n        .startsWith(ANSI_ESCAPE_LINK);\n    }\n\n    if (isInsideEscape) {\n      if (isInsideLinkEscape) {\n        if (character === ANSI_ESCAPE_BELL) {\n          isInsideEscape = false;\n          isInsideLinkEscape = false;\n        }\n      } else if (character === ANSI_SGR_TERMINATOR) {\n        isInsideEscape = false;\n      }\n\n      continue;\n    }\n\n    visible += characterLength;\n\n    if (visible === columns && index < characters.length - 1) {\n      rows.push(\"\");\n      visible = 0;\n    }\n  }\n\n  // It's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case\n  if (!visible && String(rows[rows.length - 1]).length > 0 && rows.length > 1) {\n    rows[rows.length - 2] = String(rows[rows.length - 1]) + rows.pop();\n  }\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = (str: string) => {\n  const words = str.split(\" \");\n  let last = words.length;\n\n  while (last > 0) {\n    if (stringWidth(String(words[last - 1])) > 0) {\n      break;\n    }\n\n    last--;\n  }\n\n  if (last === words.length) {\n    return str;\n  }\n\n  return words.slice(0, last).join(\" \") + words.slice(last).join(\"\");\n};\n\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nexport type Options = { trim?: boolean; wordWrap?: boolean; hard?: boolean };\nconst exec = (str: string, columns: number, options: Options = {}) => {\n  if (options.trim !== false && str.trim() === \"\") {\n    return \"\";\n  }\n\n  let returnValue = \"\";\n  let escapeCode;\n  let escapeUrl;\n\n  const lengths = wordLengths(str);\n  let rows = [\"\"];\n\n  for (const [index, word] of str.split(\" \").entries()) {\n    if (options.trim !== false) {\n      rows[rows.length - 1] = String(rows[rows.length - 1]).trimStart();\n    }\n\n    let rowLength = stringWidth(String(rows[rows.length - 1]));\n\n    if (index !== 0) {\n      if (\n        rowLength >= columns &&\n        (options.wordWrap === false || options.trim === false)\n      ) {\n        // If we start with a new word but the current row length equals the length of the columns, add a new row\n        rows.push(\"\");\n        rowLength = 0;\n      }\n\n      if (rowLength > 0 || options.trim === false) {\n        rows[rows.length - 1] += \" \";\n        rowLength++;\n      }\n    }\n\n    // In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n    const len = Number(lengths[index]);\n    if (options.hard && len > columns) {\n      const remainingColumns = columns - rowLength;\n      const breaksStartingThisLine =\n        1 + Math.floor((len - remainingColumns - 1) / columns);\n      const breaksStartingNextLine = Math.floor((len - 1) / columns);\n      if (breaksStartingNextLine < breaksStartingThisLine) {\n        rows.push(\"\");\n      }\n\n      wrapWord(rows, word, columns);\n      continue;\n    }\n\n    if (rowLength + len > columns && rowLength > 0 && len > 0) {\n      if (options.wordWrap === false && rowLength < columns) {\n        wrapWord(rows, word, columns);\n        continue;\n      }\n\n      rows.push(\"\");\n    }\n\n    if (rowLength + len > columns && options.wordWrap === false) {\n      wrapWord(rows, word, columns);\n      continue;\n    }\n\n    rows[rows.length - 1] += word;\n  }\n\n  if (options.trim !== false) {\n    rows = rows.map((row) => stringVisibleTrimSpacesRight(row));\n  }\n\n  const pre = [...rows.join(\"\\n\")];\n\n  for (const [index, character] of pre.entries()) {\n    returnValue += character;\n\n    if (ESCAPES.has(character)) {\n      const { groups } = (new RegExp(\n        `(?:\\\\${ANSI_CSI}(?<code>\\\\d+)m|\\\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`,\n      ).exec(pre.slice(index).join(\"\")) || { groups: {} }) as {\n        groups: {\n          code?: string;\n          uri?: string;\n        };\n      };\n      if (groups.code !== undefined) {\n        const code = Number.parseFloat(groups.code);\n        escapeCode = code === END_CODE ? undefined : code;\n      } else if (groups.uri !== undefined) {\n        escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;\n      }\n    }\n\n    const code = ansiStyles.codes.get(Number(escapeCode));\n\n    if (pre[index + 1] === \"\\n\") {\n      if (escapeUrl) {\n        returnValue += wrapAnsiHyperlink(\"\");\n      }\n\n      if (escapeCode && code) {\n        returnValue += wrapAnsiCode(code);\n      }\n    } else if (character === \"\\n\") {\n      if (escapeCode && code) {\n        returnValue += wrapAnsiCode(escapeCode);\n      }\n\n      if (escapeUrl) {\n        returnValue += wrapAnsiHyperlink(escapeUrl);\n      }\n    }\n  }\n\n  return returnValue;\n};\n\n// For each newline, invoke the method separately\nexport const wrap = (str: string, columns: number, options: Options) =>\n  String(str)\n    .normalize()\n    .replace(/\\r\\n/g, \"\\n\")\n    .split(\"\\n\")\n    .map((line) => exec(line, columns, options))\n    .join(\"\\n\");\n"]}